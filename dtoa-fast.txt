Author: Albert Chan
email : albertmcchan@yahoo.com

### GOAL: code for shortest decimals conversion
### Algorithm: re-use strtod_fast code for scalings + round-trip tests
### Scale Double into 16-17 digits MANTISSA + FRAC
### Scale AGAIN, range = MANTISSA + FRAC +/- SAFE_ULP, SAFE_ULP = [0.5,5)

SCALE Tricks
============
Instead of scaling double to 17 decimal digits MANTISSA,
the code scale upto 56 bits (3.6E15 to 7.2E16)

BITS  ULP RANGES
56       2 -   8    <- scale DOWN [5, 8]
55       1 -   4    <- ok
54     0.5 -   2    <- ok
53    0.25 -   1    <- scale UP [0.25, 0.5]
52   0.125 - 0.5    <- scale UP for all

ERROR ANALYSIS
==============
IEEE Double to 96 bits is exact (53 bits -> 96 bits)
Splitting bits into mantissa/frac is also EXACT
At most 56 bits MANTISSA stored in 64 bit integer
At least 96 - 56 = 40 bits FRAC stored in 53 bit double
Error to scale safe ulp < 5 can be ignored (53 bits double)

Because of the SPLITTING MANTISSA + FRAC,
max abs error of FRAC occurs when MANTISSA is maximized

For maximum 17 digits number: 1e17 = 0.69389 * 2^57
Max abs error = 18.7026 m + 1 = 13.978 = 13 ulp
ERR = 16 ulp = 16 * 2^(57-96) = 0x1p-35 should suffice

True value = [MANTISSA + FRAC, MANTISSA + FRAC + ERR)
           < (MANTISSA + FRAC) +/- ERR

Prove dtoa_safe work
====================

A.  PROVE SAFE = 1-2ERR is enough, even with worst rounding errors.
    Because safe/edge factor is multiplied into ulp, worst case
    for ulp calculation is when ulp = 0.5 (smallest)

    safe ulp = ulp(1 - 2ERR) = 0.5 - ERR
    edge ulp = ulp(1 + 2ERR) = 0.5 + ERR

    error of mantissa + frac < ERR (see above)
    -> safe ulp exclude edges, edge ulp included BOTH edges
    Since it holds for ulp=0.5, it holds for ulp = [0.5, 5)

B.  PROVE safe range = [m + i, m + j], j-i < 10:
    exact ulp = mantissa of decimal string of 2 ^ n

    closest ulp ~ 5:
    n       value               safe ulp
    -486    5.00520774E-147     5.00520774 = 0.500520774 * 10
    -1      0.5                 5 (1-2ERR) = 4.9999999997089617
    484     4.99479768E+145     4.99479768

    max(SAFE_ULP) = 4.9999999997089617
    i = ceil (FRAC - SAFE_ULP)
    j = floor(FRAC + SAFE_ULP)

    j-i <= int(2 * SAFE_ULP) = 9 < 10 (even with rounding errors)

C.  PROVE any shorter edge that round-trip is best case,
    i.e. no need to consider the other edge

    For n != -1, since SAFE = 1-2ERR = 0.99999999994179234 ~ 1:
    safe ulp = edge ulp = [0.500520774, 4.99479768]
    -> IMPOSSIBLE to have 2 edges

    For n = -1, best edge MUST be integer
    Let x = m + 0.5:
    FE_TONEAREST, best = m + (m % 2)
    FE_TOWARDZERO best = m + (m < 0)
    FE_UPWARD     best = m + 1
    FE_DOWNWARD   best = m
    -> IMPOSSIBLE to have 2 edges

SHORTEST decimal digits
=======================
edge that may be a '0' + SHORTEST + ROUND-TRIP -> best edge

If edge is no good, safe range = [lo, hi] = [m + i, m + j]

if lo//10 != hi//10:            # tens different
    safe = hi with DIFFERED digits - 1 removed
elif lo%10 == 0 or hi%10 == 0:  # can shorten 1 digit
    safe = hi with 1 digit removed

if abs(frac-0.5) >= ERR         # rouding for closest digits
    safe = m + (frac>0.5)
else
    safe = lrint(m + frac)      # use MAPM C Library

Examples:
range = 236.2 +/- 0.6 = [235.6, 236.8] = [236, 236] -> 236
range = 236.2 +/- 1.6 = [234.6, 237.8] = [235, 237] -> 236
range = 236.2 +/- 3.9 = [232.3, 240.1] = [233, 240] -> 24
range = 12999 +/- 1.1 = [12997.9, 13000.1] = [12998, 13000] -> 13
range = 12999 +/- 2.1 = [12996.9, 13001.1] = [12997, 13001] -> 13

dtoa_fast.c is born ! 2/20/16
=============================

### Normal Double
>sum-mode 4.3915445623487279e17
mantissa => 43915445623487276 + 0.79999999999836291
safe ulp => 3.1999999998137358
safe = 43915445623487274 to 43915445623487279
edge = .4391544562348728E18 FAILED
best = 43915445623487277
+0x1.860c29ad5a33fp+58 = +4.3915445623487277e17

### Subnormals
>sum-mode 4.502463450621225E-321
mantissa => 4500 + 0.93803361375601735
safe ulp => 2.4703282290624431
safe = 4499 to 4503
best = 45
+0x0.000000000038fp-1022 = +4.5e-321

ROUNDING THEOREM
================
max safe ulp = 5 * (1-2ERR) = 4.9999999997089617 -> j-i < 10

EVEN if safe ulp = nextafter(5, 0) = 4.9999999999999991,
the following PROVES that j-i <= int(nextafter(10, 0)) < 10

Assume: X, Y both IEEE double, X > Y > 0 AND 2X not overflow
PROVE: IF bexp(X+Y) == bexp(X), THEN (X + Y) + (X - Y) == 2X

Consider mantissa only with "binary" point lined-up

LET X = 0.1 x[2] ... x[53]
LET Y = 0.(k zeroes)1 y[2] ... y[53]

Before rounding:
X + Y = 0.1 s[2] ... s[53]  (y[54-k] ... y[53])
X - Y = 0.d[1] ..... d[53] ~(y[54-k] ... y[53])

NOTE: Negative indexes allowed, e.g. y[0] = y[-1] = ... = 0
      -> roundings bits can be MORE than 53 bits

Case 1: non Half-way
    NOTE: X+Y rounding bits == flip of X-Y rounding bits
    Due to flipped bits, both round in opposite direction.

Case 2 Half-way:
    Before rounding:
    s[53] = (x[53] + y[53-k]) & 1       // room for 1 bit only
    d[53] = (x[53] - 1 - y[53-k]) & 1   // borrowed 1 for bit-54
          = (x[53] + y[53-k] + 1) & 1

    Thus, s[53] = ~d[53]
    Again, roundings in opposite direction.
    If one round-up to even, the other must round-down to even
    Both roundings cancel each other out.

QED

dtoa_boundary()
===============
4/29/16: Rick Regan article "Shortest digit NOT round-trip"
I had assumed next_above(x) - x == x - next_below(x),
In other words, for FE_TONEAREST, range = frac +/- ulp

dtoa_boundary() is created, so range = [x - ulp/2, x + ulp].
The code is much simplified without considering edge cases
but CONFIRM by brute force that match dtoa_gay.

3/11/2017: Redo error analysis for 0x1p-1022 to 0x1p1023

Only **ONE** case with frac within 0.5 +/- 0.0001 :

0x1p-25  = 2.98023223876953125E-8       # halfway case frac = 0.5
shortest = 2.9802322387695312E-8        # round-down-to-even

-> mantissa = 29802322387695312 + 0.5   # mantissa NEVER over-estimate
-> no further scalings ->  frac = 0.5   # **NO** floating point math !
-> dtoa_boundary does round-half-up
-> frac chopped (as required)

dtoa_do_digit()
===============
return value similar to mode 2 of dtoa_gay
Since double has only 53 bits accurary,
number of decimal digits is limited to 17.

dtoa-mode.c
===========
dtoa-fast.c, regardless of rounding mode, ALWAYS assume FE_TONEAREST.
dtoa-mode.c, however, check the rounding mode, and round accordingly.
If user use flip operator to the number of digits requested, the
code assumed rounding in opposite direction.

So, the following is ALWAYS true (ALL rounding MODES)
strtod(dtoa(x, ~0)) == x
strtod(dtoa(x,~17)) == x

### STASTICS 12/31/16
SCALE
    998358  samples
    136689  scale up (x10) FAST
     52681  scale down (/ SCALE)
    808988  no scalings

EDGE CASES
       267  bot edge, 169 round-trip
       274  top edge, 172 round-trip

SAFE CASES
    497071  digits shorten FAST
    500602  need correction = (frac>0.5) - j
       344  hard case, frac ~ 0.5

EASY CASES = 497071 + 500602 = 997673 (or 99.93%!)

BITS    samples
  56    211474
  55    199585
  54    198071
  53    384027
  52    5208

dtoa-ifmt.c 2/8/17
==================
Added a poor man's sprintf.
(conversion done inplace for efficiency)

Usage:
s = dtoa_fast(3.1416, 0, &sgn, &len, &dec); // s = "31416"
s = dtoa_ifmt(s, sgn, len, dec, 'G');       // s = "3.1416"

mode 'r' -> "31416e-004"  = raw form w/ integer mantissa
mode 'e' -> "3.1416e+000" = normalized mantissa
mode 'g' -> "3.1416"      = shortest form
capitalized mode uses 'E' for exponent

Above work without allocation because dtoa_fast
returned string have some spare room to add sign,
zeroes, dec pt, and exponents

For dtoa.c output, we need to create spare room.
To cover all the fmt modes, s[-6] .. s[len + 5]
must be pre-allocated

Example for shortest digits:
char buf[17+12];    // shortest may have 17 digits
char *s = buf + 6;  // now s[-6], s[17+5] is valid

s = dtoa_r(x, 0, 0, &dec, &sgn, &e, s, sizeof(buf)-6);
s = dtoa_ifmt(s, sgn, e-s, dec, 'g');
