Author: Albert Chan
email : albertmcchan@yahoo.com

### GOAL: code for shortest decimals conversion
### Algorithm: re-use strtod_fast code for scalings + round-trip tests
### Scale Double into 16-17 digits MANTISSA + FRAC
### Scale AGAIN, range = MANTISSA + FRAC +/- SAFE_ULP, SAFE_ULP = [0.5,5)

SCALE Tricks
============
Instead of scaling double to 17 decimal digits MANTISSA,
the code scale upto 56 bits (3.6E15 to 7.2E16)

BITS  ULP RANGES (for normals)
56       2 -   8    <- scale DOWN [5, 8]
55       1 -   4    <- ok
54     0.5 -   2    <- ok
53    0.25 -   1    <- scale UP [0.25, 0.5]
52   0.125 - 0.5    <- scale UP for all

ERROR ANALYSIS
==============
IEEE Double to 96 bits is exact (53 bits -> 96 bits)
Splitting bits into mantissa/frac is also EXACT
At most 56 bits MANTISSA stored in 64 bit integer
At least 96 - 56 = 40 bits FRAC stored in 53 bit double
Error to scale safe ulp < 5 can be ignored (53 bits double)

Because of the SPLITTING MANTISSA + FRAC,
max abs error of FRAC occurs when MANTISSA is maximized

For maximum 17 digits number: 1e17 = 0.69389 * 2^57
Max abs error = 18.7026 m + 1 = 13.978 = 13 ulp
ERR = 16 ulp = 16 * 2^(57-96) = 0x1p-35 should suffice

True value = [MANTISSA + FRAC, MANTISSA + FRAC + ERR)
           < (MANTISSA + FRAC) +/- ERR

Prove dtoa_shortest() work
==========================

A.  PROVE safe/edge ulp good enough, even with worst errors.

    Because safe/edge factor is multiplied into ulp, worst case
    for ulp calculation is when ulp = 0.5 (smallest)
    
    safe ulp = ulp(1 - 2ERR) <= ulp - ERR
    edge ulp = ulp(1 + 2ERR) >= ulp + ERR

    max frac error < ERR (see above)
    -> safe ulp exclude edges, edge ulp included BOTH edges

B.  PROVE safe range = [m + i, m + j], j-i < 10:
    exact ulp = mantissa of decimal string of 2 ^ n

    closest ulp ~ 5:
    n       value               safe ulp
    -486    5.00520774E-147     5.00520774 = 0.500520774 * 10
    -1      0.5                 5 (1-2ERR) = 4.9999999997
    484     4.99479768E+145     4.99479768

    max(safe ulp) = 4.9999999997
    i = ceil (frac - safe ulp)
    j = floor(frac + safe ulp)

    max(j-i) = int(2 * max(safe ulp)) = 9 < 10    

SHORTEST decimal digits
=======================

safe range math is best shown by example:
range = 236.2 +/- 0.6 = [235.6, 236.8] = [236, 236] -> 236
range = 236.2 +/- 1.6 = [234.6, 237.8] = [235, 237] -> 236
range = 236.2 +/- 3.9 = [232.3, 240.1] = [233, 240] -> 24
range = 12999 +/- 1.1 = [12997.9, 13000.1] = [12998, 13000] -> 13
range = 12999 +/- 2.1 = [12996.9, 13001.1] = [12997, 13001] -> 13

edge case:
range = [1007.2, 1009.99999999] = [1008, 1009] -> 1009 ?
edge "101" is shorter than 1009 
-> if round-trip, then "101" is best

hard case:
range = 134.5 +/- 1.7 = [132.8, 136.2] = [133, 136] -> ?
-> best case depends on exact fractions, not an estimate
-> need arbitrary precision math to decide

dtoa_fast.c is born ! 2/20/16
=============================

### Normal Double
>test 4.3915445623487279e17
mantissa => 43915445623487276 + 0.79999999999836291
safe ulp => 3.1999999998137358
safe = 43915445623487274 to 43915445623487279
edge = .4391544562348728E18 FAILED
best = 43915445623487277
+0x1.860c29ad5a33fp+58 = 4.3915445623487277e17

### Subnormals
>test 4.502463450621225E-321
mantissa => 4500 + 0.93803361375601735
safe ulp => 2.4703282290624431
safe = 4499 to 4503
best = 45
+0x0.000000000038fp-1022 = 4.5e-321

dtoa_boundary()
===============
4/29/16: Rick Regan article "Shortest digit NOT round-trip"
I had assumed next_above(x) - x == x - next_below(x),
In other words, for FE_TONEAREST, range = frac +/- ulp

dtoa_boundary() is created, so range = [x - ulp/2, x + ulp].
The code is much simplified without considering edge cases
but CONFIRM by brute force that match dtoa_gay.

3/11/2017: Redo error analysis for 0x1p-1022 to 0x1p1023

Only **ONE** case with frac within 0.5 +/- 0.0001 :

0x1p-25  = 2.98023223876953125E-8       # halfway case frac = 0.5
shortest = 2.9802322387695312E-8        # round-down-to-even

-> mantissa = 29802322387695312 + 0.5   # mantissa NEVER over-estimate
-> no further scalings ->  frac = 0.5   # **NO** floating point math !
-> dtoa_boundary does round-half-up
-> frac chopped (as required)

dtoa_do_digit()
===============
return value similar to mode 2 of dtoa_gay
Since double has only 53 bits accurary,
number of decimal digits is limited to 17.

dtoa-mode.c
===========
dtoa-fast.c, regardless of rounding mode, ALWAYS assume FE_TONEAREST.
dtoa-mode.c, however, check the rounding mode, and round accordingly.
If user use flip operator to the number of digits requested, the
code assumed rounding in opposite direction.

So, the following is ALWAYS true (ALL rounding MODES)
strtod(dtoa(x, ~0)) == x
strtod(dtoa(x,~17)) == x

dtoa_shortest in FE_UPWARD mode
===============================
let ulp_exact = ulp + k ERR
then ulp_edge = ulp_exact + k ERR = ulp + 2k ERR

since ulp = [0.5, 5) -> k = [1, 10)

 ERR             2 * ulp            (2k-1)ERR
|...--------------------------------........|
   m+frac+ERR

safe range = [m+frac+ERR, m+frac+ERR + 2*ulp]
           = m + (frac+ERR+ulp) +/- ulp
           
bot edge = m + (frac+ERR+ulp) - ulp_edge
         = m + frac + ERR + ulp - (ulp + 2k ERR)
         = m + frac - (2k-1)ERR
         < m + frac_exact

top edge = m + (frac+ERR+ulp) + ulp_edge
         = m + (frac + ERR) + (ulp + ulp_edge)
         > m + frac_exact + 2*ulp_exact

-> same logic will work other directed modes

### STASTICS 12/31/16
SCALE
    998358  samples
    136689  scale up (x10) FAST
     52681  scale down (/ SCALE)
    808988  no scalings

EDGE CASES
       267  bot edge, 169 round-trip
       274  top edge, 172 round-trip

SAFE CASES
    497071  digits shorten FAST
    500602  need correction = (frac>0.5) - j
       344  hard case, frac ~ 0.5

EASY CASES = 497071 + 500602 = 997673 (or 99.93%!)

BITS    samples
  56    211474
  55    199585
  54    198071
  53    384027
  52    5208

dtoa-ifmt.c 2/8/17
==================
Added a poor man's sprintf (inplace conversion for speed)

Usage:
s = dtoa_fast(3.1416, 0, &sgn, &len, &dec); // s = "31416"
s = dtoa_ifmt(s, sgn, len, dec, 'G');       // s = "3.1416"

mode 'r' -> "31416e-004"  = raw form w/ integer mantissa
mode 'e' -> "3.1416e+000" = normalized mantissa
mode 'g' -> "3.1416"      = shortest form
capitalized mode uses 'E' for exponent

Above work without allocation because dtoa_fast
returned string have some spare room to add sign,
zeroes, dec pt, and exponents

For dtoa.c output, we need to create spare room.
To cover all the fmt modes, s[-6] .. s[len + 6]
must be pre-allocated

Example for shortest digits:
char buf[17+12];    // shortest may have 17 digits
char *s = buf + 6;  // now s[-6], s[17+5] is valid

s = dtoa_r(x, 0, 0, &dec, &sgn, &e, s, sizeof(buf)-6);
s = dtoa_ifmt(s, sgn, e-s, dec, 'g');
